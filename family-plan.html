<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Family Capacity Planner</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { theme: { extend: { boxShadow: { glow: "0 0 0 3px rgba(239,68,68,0.5)" } } } };
  </script>
  <style>
    :root{ --hour-width: 64px; --slot: 15; }

    /* timeline grid */
    .timeline { pointer-events:none; background: repeating-linear-gradient(to right, rgba(0,0,0,.05) 0, rgba(0,0,0,.05) 1px, transparent 1px, transparent var(--hour-width)); }
    .timeline.half { background: repeating-linear-gradient(to right, transparent 0, transparent calc(var(--hour-width)/2 - 1px), rgba(0,0,0,.05) calc(var(--hour-width)/2), transparent calc(var(--hour-width)/2 + 1px)); }

    /* bars */
    .bar { user-select: none; cursor: grab; transition: box-shadow .15s ease, transform .06s ease, background-color .15s ease, opacity .2s ease; display:flex; align-items:center; position:relative; justify-content:space-between; }
    .bar:hover { box-shadow: 0 4px 12px rgba(0,0,0,.15); opacity: 0.98; }
    .bar.dragging { cursor: grabbing; opacity: 1; box-shadow: 0 6px 18px rgba(0,0,0,.2); }
    .viol { box-shadow: 0 0 0 3px rgba(239,68,68,0.6) !important; }
    .handle { width: 8px; height: 100%; transition: background .1s ease; cursor: ew-resize; }
    .bar:hover .handle { background: rgba(0,0,0,.18); }

    /* captions: overlay + global flycap */
    .caption { position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; padding: 0 4px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; pointer-events: none; }
    .bar.small .caption { opacity: 0; }
    #flycap { position: fixed; z-index: 50; pointer-events: none; background: #111; color: #fff; font-size: 11px; font-weight: 600; padding: 2px 6px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,.18); opacity: 0; transform: translate(-50%, -6px); transition: opacity .12s ease, transform .12s ease; left: -9999px; top: -9999px; }
    #flycap.show { opacity: 1; transform: translate(-50%, -2px); }

    /* lanes */
    .lane { position: relative; height: 36px; border: 1px solid rgba(0,0,0,.06); border-radius: 10px; background: #fafafa; transition: background-color .15s ease, box-shadow .15s ease; overflow: hidden; }
    .lane:hover { background: #f3f4f6; box-shadow: inset 0 0 0 1px rgba(0,0,0,.08); }
    [data-person-lanes] > .lane:nth-child(even){ background: #f0f0f0; }
    [data-person-lanes] > .lane:nth-child(even):hover { background: #e7e7e7; }
    [data-person-lanes] > .lane + .lane { margin-top: 6px; }

    /* day sections as clear visual units */
    .day-card { background: #fff; border: 1px solid rgba(0,0,0,.08); border-radius: 14px; box-shadow: 0 1px 3px rgba(0,0,0,.05); margin: 10px; overflow: hidden; }
    .day-card .day-header { background: linear-gradient(180deg, #f9fafb, #f3f4f6); font-weight: 600; color: #374151; }
  </style>
</head>
<body class="bg-gray-50 text-gray-800">
  <div class="max-w-[1400px] mx-auto p-6 space-y-6">
    <header class="flex items-center justify-between gap-4">
      <h1 class="text-2xl font-bold">Family Capacity Planner</h1>
      <div class="flex items-center gap-2">
        <button id="saveBtn" class="px-3 py-2 rounded-xl bg-blue-600 text-white shadow hover:bg-blue-700">Save</button>
        <button id="loadBtn" class="px-3 py-2 rounded-xl bg-blue-100 text-blue-700 hover:bg-blue-200">Load</button>
        <button id="resetBtn" class="px-3 py-2 rounded-xl bg-gray-100 hover:bg-gray-200">Reset</button>
        <button id="diagBtn" class="px-3 py-2 rounded-xl bg-purple-600 text-white hover:bg-purple-700">Diagnostics</button>
      </div>
    </header>

    <!-- Config Panel -->
    <section class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <div class="lg:col-span-2 bg-white rounded-2xl shadow p-4 space-y-4">
        <h2 class="font-semibold">People & Constraints</h2>
        <div class="overflow-x-auto">
          <table class="min-w-full text-sm">
            <thead>
              <tr class="text-left text-gray-500">
                <th class="py-2">Name</th>
                <th>Color</th>
                <th title="Minimum working hours per day">Daily Min (h)</th>
                <th title="Maximum working hours per day">Daily Max (h)</th>
                <th title="Minimum working hours per week">Weekly Min (h)</th>
                <th title="Maximum working hours per week">Weekly Max (h)</th>
                <th></th>
              </tr>
            </thead>
            <tbody id="peopleRows" class="align-top"></tbody>
          </table>
        </div>
        <div class="grid grid-cols-2 md:grid-cols-4 gap-3 pt-3">
          <label class="text-sm">Start hour
            <input id="startHour" type="number" min="0" max="23" class="w-full mt-1 rounded-xl border-gray-200" value="6"/>
          </label>
          <label class="text-sm">End hour
            <input id="endHour" type="number" min="1" max="24" class="w-full mt-1 rounded-xl border-gray-200" value="20"/>
          </label>
          <label class="text-sm">Snap (min)
            <input id="snapMin" type="number" min="5" step="5" class="w-full mt-1 rounded-xl border-gray-200" value="15"/>
          </label>
          <label class="text-sm">Hour width (px)
            <input id="hourWidth" type="number" min="24" step="4" class="w-full mt-1 rounded-xl border-gray-200" value="64"/>
          </label>
        </div>
        <div class="text-xs text-gray-500">Tip: Click empty lane space to create an interval. Drag the bar to move; drag either edge to resize. Middle- or right-click a bar to delete.</div>
      </div>
      <aside class="bg-white rounded-2xl shadow p-4 space-y-3">
        <h2 class="font-semibold">Weekly Summary</h2>
        <div id="summary" class="space-y-2 text-sm"></div>
        <div class="text-xs text-gray-500 border-t pt-3">Bars turn red if a day or week violates constraints. Day totals include all intervals.</div>
      </aside>
    </section>

    <!-- Schedule Grid -->
    <section class="bg-white rounded-2xl shadow">
      <div class="flex items-center justify-between p-4 border-b">
        <h2 class="font-semibold">Week Planner</h2>
        <div class="text-sm text-gray-500" id="hoursHeader"></div>
      </div>
      <div class="overflow-auto" id="gridScroller">
        <div id="grid" class="min-w-[900px]"></div>
      </div>
    </section>
  </div>

  <template id="personRowTpl">
    <tr>
      <td class="py-2 pr-3"><input class="name w-full rounded-xl border-gray-200" /></td>
      <td class="pr-3"><input type="color" class="color w-10 h-8 p-0 border rounded"/></td>
      <td class="pr-3"><input class="dmin w-20 rounded-xl border-gray-200" type="number" min="0" step="0.25"/></td>
      <td class="pr-3"><input class="dmax w-20 rounded-xl border-gray-200" type="number" min="0" step="0.25"/></td>
      <td class="pr-3"><input class="wmin w-20 rounded-xl border-gray-200" type="number" min="0" step="0.5"/></td>
      <td class="pr-3"><input class="wmax w-20 rounded-xl border-gray-200" type="number" min="0" step="0.5"/></td>
      <td class="text-right"><button class="remove px-2 py-1 text-xs rounded-lg bg-gray-100 hover:bg-red-100">Remove</button></td>
    </tr>
  </template>

  <!-- Day section template (row per day) -->
  <template id="daySectionTpl">
    <div class="day-card">
      <div class="grid grid-cols-[140px_1fr]">
        <div class="day-header bg-gray-50/80 backdrop-blur border-r p-3 text-sm font-semibold text-gray-700 sticky left-0" data-day-label>Day</div>
        <div class="relative">
          <div class="absolute inset-0 timeline half"></div>
          <div class="p-2" data-person-lanes></div>
        </div>
      </div>
    </div>
  </template>

  <!-- Person lane inside a day -->
  <template id="laneTpl">
    <div class="lane relative rounded-xl">
      <div class="absolute inset-0 pointer-events-none">
        <div class="absolute inset-0 timeline"></div>
      </div>
      <div class="absolute -left-2 top-1/2 -translate-y-1/2 text-xs text-gray-500 w-36 text-right pr-3" data-label></div>
      <div class="absolute inset-0" data-slot></div>
    </div>
  </template>

  <template id="barTpl">
    <div class="bar absolute" style="top:4px;height:28px;min-width:24px; border-radius:10px; box-shadow: 0 1px 2px rgba(0,0,0,.08)">
      <div class="handle" data-edge="l" title="Resize"></div>
      <div class="mx-auto text-xs font-semibold px-2 select-none leading-[28px] whitespace-nowrap caption" data-duration>–:–</div>
      <div class="handle" data-edge="r" title="Resize"></div>
    </div>
  </template>

  <script>
  // ------- State -------
  const DAYS = ["Mon","Tue","Wed","Thu","Fri"];
  let state = {
    startHour: 6,
    endHour: 20,
    snapMin: 15,
    hourWidth: 64,
    people: [
      { id: uid(), name: "Parent A", color: "#3b82f6", dailyMin: 4, dailyMax: 8, weeklyMin: 20, weeklyMax: 40 },
      { id: uid(), name: "Parent B", color: "#10b981", dailyMin: 4, dailyMax: 8, weeklyMin: 20, weeklyMax: 40 },
      { id: uid(), name: "Child",    color: "#f59e0b", dailyMin: 0, dailyMax: 8, weeklyMin: 0,  weeklyMax: 40 },
    ],
    // schedule: map personId -> dayIndex -> [ { id, startMin, endMin } ]
    schedule: {}
  };

  function uid(){ return Math.random().toString(36).slice(2,9); }
  function hours(){ return state.endHour - state.startHour; }
  function pxPerMin(){ return state.hourWidth / 60; }
  function minToPx(m){ return Math.round(m * pxPerMin()); }
  function pxToMin(px){ return Math.round(px / pxPerMin()); }
  function timeToMin(t){ return t*60; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
  function snapMinFunc(v){ const s = state.snapMin; return Math.round(v / s) * s; }
  function fmtHM(min){ const h = Math.floor(min/60), m=min%60; return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`; }
  function minsToH(min){ return +(min/60).toFixed(2); }
  function hexToRgb(hex){
    let h = hex.trim();
    if(/^#/.test(h)) h = h.slice(1);
    if(h.length===3) h = h.split('').map(c=>c+c).join('');
    const num = parseInt(h,16);
    return { r: (num>>16)&255, g: (num>>8)&255, b: num&255 };
  }

  const peopleRows = document.getElementById('peopleRows');
  const grid = document.getElementById('grid');
  const hoursHeader = document.getElementById('hoursHeader');
  const tplPerson = document.getElementById('personRowTpl');
  const tplDaySection = document.getElementById('daySectionTpl');
  const tplLane = document.getElementById('laneTpl');
  const tplBar = document.getElementById('barTpl');
  const summary = document.getElementById('summary');

  // ------- Global flycap (body-level so it's never clipped) -------
  let flycapEl = null;
  function ensureFlycap(){
    if(!flycapEl){
      flycapEl = document.createElement('div');
      flycapEl.id = 'flycap';
      document.body.appendChild(flycapEl);
    }
  }
  function showFlycapForBar(bar, text){
    ensureFlycap();
    const rect = bar.getBoundingClientRect();
    flycapEl.textContent = text;
    flycapEl.style.left = (rect.left + rect.width/2) + 'px';
    flycapEl.style.top = (rect.top) + 'px';
    flycapEl.classList.add('show');
  }
  function hideFlycap(){ if(flycapEl){ flycapEl.classList.remove('show'); } }
  function syncFlycapForBar(bar){
    const tEl = bar.querySelector('[data-duration]');
    if(!tEl) return;
    const text = tEl.textContent || '';
    if(bar.classList.contains('dragging') || bar.classList.contains('small')){
      showFlycapForBar(bar, text);
    }
  }

  // ------- Ensure schedule + People table -------
  function ensureSchedule(){
    for(const p of state.people){
      if(!state.schedule[p.id]) state.schedule[p.id] = {};
      for(let d=0; d<5; d++){
        if(!state.schedule[p.id][d]){
          state.schedule[p.id][d] = [ { id: uid(), startMin: timeToMin(9), endMin: timeToMin(13) } ];
        }
      }
    }
  }

  function renderPeopleTable(){
    peopleRows.innerHTML = '';
    for(const p of state.people){
      const row = tplPerson.content.firstElementChild.cloneNode(true);
      row.querySelector('.name').value = p.name;
      row.querySelector('.color').value = p.color;
      row.querySelector('.dmin').value = p.dailyMin;
      row.querySelector('.dmax').value = p.dailyMax;
      row.querySelector('.wmin').value = p.weeklyMin;
      row.querySelector('.wmax').value = p.weeklyMax;
      row.querySelector('.remove').onclick = () => { removePerson(p.id); };
      row.querySelectorAll('input').forEach(inp=>{
        inp.oninput = () => {
          p.name = row.querySelector('.name').value;
          p.color = row.querySelector('.color').value;
          p.dailyMin = +row.querySelector('.dmin').value;
          p.dailyMax = +row.querySelector('.dmax').value;
          p.weeklyMin = +row.querySelector('.wmin').value;
          p.weeklyMax = +row.querySelector('.wmax').value;
          renderGrid();
        };
      });
      peopleRows.appendChild(row);
    }
  }
  function removePerson(id){
    state.people = state.people.filter(p=>p.id!==id);
    delete state.schedule[id];
    renderAll();
  }

  // ------- Hours header -------
  function renderHoursHeader(){
    const labels = [];
    for(let h=state.startHour; h<=state.endHour; h++) labels.push(h.toString().padStart(2,'0'));
    const first = labels.length ? labels[0] : '';
    const last = labels.length ? labels[labels.length-1] : '';
    hoursHeader.textContent = `${first}:00 — ${last}:00 • ${hours()}h | snap ${state.snapMin}m`;
    document.documentElement.style.setProperty('--hour-width', state.hourWidth + 'px');
  }

  // ------- GRID: 5 day rows; each contains N person lanes stacked -------
  function renderGrid(){
    ensureSchedule();
    renderHoursHeader();
    grid.innerHTML = '';

    for(let d=0; d<5; d++){
      const dayFrag = tplDaySection.content.cloneNode(true);
      const daySec = dayFrag.firstElementChild;
      const dayLabelEl = daySec.querySelector('[data-day-label]');
      if(dayLabelEl) dayLabelEl.textContent = DAYS[d];
      const lanesHost = daySec.querySelector('[data-person-lanes]');

      const dayW = hours() * state.hourWidth;

      for(const p of state.people){
        const lane = tplLane.content.firstElementChild.cloneNode(true);
        const slot = lane.querySelector('[data-slot]');
        lane.querySelector('[data-label]').textContent = p.name;
        slot.style.width = dayW + 'px';
        slot.style.height = '100%';

        // Click to add interval only on empty lane space
        slot.addEventListener('mousedown', (e)=>{
          if (e.button !== 0) return; // left only
          if (e.target.closest('.bar')) return;
          slot._down = { x: e.clientX, y: e.clientY, t: performance.now() };
        });
        slot.addEventListener('mouseup', (e)=>{
          if (e.button !== 0) return;
          if (!slot._down) return;
          const moved = Math.hypot(e.clientX - slot._down.x, e.clientY - slot._down.y);
          const dt = performance.now() - slot._down.t;
          slot._down = null;
          if (moved > 3 || dt > 600) return; // treat as drag or long-press -> ignore create
          const rect = slot.getBoundingClientRect();
          const x = e.clientX - rect.left; // px within lane
          const startRelMin = pxToMin(x);
          const dayStart = timeToMin(state.startHour);
          let s = dayStart + startRelMin; s = snapMinFunc(s);
          const eMin = s + Math.max(state.snapMin*4, state.snapMin); // default ~1h
          addInterval(p.id, d, s, Math.min(dayStart + timeToMin(hours()), eMin));
        });

        // Render intervals for this person/day
        const intervals = state.schedule[p.id][d] || [];
        for(const it of intervals){
          const bar = renderBar(p, d, it);
          slot.appendChild(bar);
        }
        lanesHost.appendChild(lane);
      }

      grid.appendChild(daySec);
    }

    computeAndRenderSummary();
  }

  function renderBar(p, d, it){
    const bar = tplBar.content.firstElementChild.cloneNode(true);
    bar.style.backgroundColor = p.color;
    bar.style.outline = `1px solid rgba(0,0,0,.08)`;

    try { const rgb = hexToRgb(p.color); const lum = 0.2126*(rgb.r/255) + 0.7152*(rgb.g/255) + 0.0722*(rgb.b/255); bar.style.color = lum > 0.6 ? '#111' : '#fff'; } catch(_) { bar.style.color = '#111'; }

    bar.dataset.pid = p.id; bar.dataset.day = d; bar.dataset.iid = it.id;
    positionBar(bar, it);

    // prevent lane clicks while interacting with bars
    bar.addEventListener('mousedown', (e)=>{ e.stopPropagation(); });
    bar.addEventListener('click', (e)=>{ e.stopPropagation(); });

    // Hover flycap for small bars
    bar.addEventListener('mouseenter', ()=>{ if(bar.classList.contains('small')) syncFlycapForBar(bar); });
    bar.addEventListener('mouseleave', ()=>{ if(!bar.classList.contains('dragging')) hideFlycap(); });

    // Quick delete
    bar.addEventListener('auxclick', (e)=>{ if(e.button===1){ e.preventDefault(); removeInterval(p.id, d, it.id); } });
    bar.addEventListener('contextmenu', (e)=>{ e.preventDefault(); removeInterval(p.id, d, it.id); });

    // Attach our drag/resize handlers
    initBarInteractions(bar, p.id, d, it);

    return bar;
  }

  function positionBar(bar, it){
    if(!bar || !bar.style || !bar.querySelector){ return; }
    const relStart = it.startMin - timeToMin(state.startHour);
    const relEnd = it.endMin - timeToMin(state.startHour);
    const x = clamp(minToPx(relStart), 0, Number.MAX_SAFE_INTEGER);
    const w = Math.max(minToPx(relEnd - relStart), 24);
    bar.style.width = w + 'px';
    bar.style.transform = `translateX(${x}px)`;

    const text = `${fmtHM(it.startMin)}–${fmtHM(it.endMin)} (${minsToH(it.endMin-it.startMin)}h)`;
    const dur = bar.querySelector('[data-duration]');
    if(dur) dur.textContent = text;
    bar.setAttribute('title', text);

    // mark small bars (hide inline caption; flycap used on hover/edit)
    if(w < 64){ bar.classList.add('small'); } else { bar.classList.remove('small'); }
  }

  // ------- Intervals ops -------
  function addInterval(pid, d, start, end){
    if(!state.schedule[pid][d]) state.schedule[pid][d] = [];
    const dayStart = timeToMin(state.startHour);
    const dayEnd = timeToMin(state.endHour);
    start = clamp(snapMinFunc(start), dayStart, dayEnd - state.snapMin);
    end = clamp(snapMinFunc(end), start + state.snapMin, dayEnd);
    const it = { id: uid(), startMin: start, endMin: end };
    state.schedule[pid][d].push(it);
    renderGrid(); // full rerender to keep DOM/state solid
  }
  function removeInterval(pid, d, iid){
    state.schedule[pid][d] = (state.schedule[pid][d]||[]).filter(x=>x.id!==iid);
    renderGrid();
  }

  // ------- Plain JS Drag/Resize -------
  function initBarInteractions(bar, pid, d, it){
    let mode = null; // 'move' | 'resize-l' | 'resize-r'
    let startX = 0; // clientX at mousedown
    let orig = { x: 0, w: 0, start: it.startMin, end: it.endMin };

    const leftHandle = bar.querySelector('[data-edge="l"]');
    const rightHandle = bar.querySelector('[data-edge="r"]');

    bar.addEventListener('mousedown', (e)=>{
      if (e.button !== 0) return; // left only
      e.preventDefault();
      if (e.target === leftHandle) mode = 'resize-l';
      else if (e.target === rightHandle) mode = 'resize-r';
      else mode = 'move';
      startX = e.clientX;
      const m = new DOMMatrixReadOnly(getComputedStyle(bar).transform);
      orig.x = m.m41 || 0;
      orig.w = bar.clientWidth;
      orig.start = it.startMin; orig.end = it.endMin;
      bar.classList.add('dragging');
      syncFlycapForBar(bar);
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp, { once: true });
    });

    function onMove(e){
      const parent = bar.parentElement; const parentW = parent.clientWidth;
      const dx = e.clientX - startX;
      if (mode === 'move'){
        let newX = clamp(orig.x + dx, 0, parentW - orig.w);
        bar.style.transform = `translateX(${newX}px)`;
        applyTransformToTimesFromPixels(newX, bar.clientWidth, pid, d, it);
      } else if (mode === 'resize-l'){
        let newX = clamp(orig.x + dx, 0, orig.x + orig.w - 24);
        let newW = clamp(orig.w + (orig.x - newX), 24, parentW - newX);
        bar.style.width = newW + 'px';
        bar.style.transform = `translateX(${newX}px)`;
        applyTransformToTimesFromPixels(newX, newW, pid, d, it);
      } else if (mode === 'resize-r'){
        let newW = clamp(orig.w + dx, 24, parentW - orig.x);
        bar.style.width = newW + 'px';
        applyTransformToTimesFromPixels(orig.x, newW, pid, d, it);
      }
      syncFlycapForBar(bar);
    }
    function onUp(){
      bar.classList.remove('dragging');
      hideFlycap();
      window.removeEventListener('mousemove', onMove);
      computeAndRenderSummary();
    }
  }

  function applyTransformToTimesFromPixels(xPx, wPx, pid, d, it){
    const startRelMin = pxToMin(xPx);
    const endRelMin = pxToMin(xPx + wPx);
    const dayStart = timeToMin(state.startHour);
    let start = dayStart + startRelMin;
    let end = dayStart + endRelMin;
    start = snapMinFunc(start);
    end = snapMinFunc(end);
    if(end - start < state.snapMin){ end = start + state.snapMin; }
    // clamp to day window
    const minStart = timeToMin(state.startHour);
    const maxEnd = timeToMin(state.endHour);
    start = clamp(start, minStart, maxEnd - state.snapMin);
    end = clamp(end, start + state.snapMin, maxEnd);
    it.startMin = start; it.endMin = end;
    positionBar(document.querySelector(`.bar[data-iid="${it.id}"]`), it);
    validateDayAndWeek(pid);
  }

  // ------- Validation & Summary -------
  function dayTotalHours(pid, d){
    const list = state.schedule[pid][d]||[]; let sum=0; for(const it of list){ sum += (it.endMin - it.startMin)/60; } return sum;
  }
  function weekTotalHours(pid){ let sum=0; for(let d=0; d<5; d++) sum += dayTotalHours(pid,d); return sum; }

  function computeAndRenderSummary(){
    summary.innerHTML = '';
    for(const p of state.people){
      const week = weekTotalHours(p.id);
      const weekViol = (week < (p.weeklyMin||0)) || (!!p.weeklyMax && week > p.weeklyMax);
      const card = document.createElement('div'); card.className = 'rounded-xl border p-3 flex flex-col gap-1';
      const head = document.createElement('div'); head.className = 'flex items-center justify-between';
      head.innerHTML = `<div class=\"flex items-center gap-2\"><span class=\"inline-block w-3 h-3 rounded-full\" style=\"background:${p.color}\"></span><span class=\"font-medium\">${p.name}</span></div><div class=\"text-sm ${weekViol? 'text-red-600 font-semibold':''}\">${week.toFixed(2)}h / wk ${p.weeklyMin? `min ${p.weeklyMin}h`:''} ${p.weeklyMax? `· max ${p.weeklyMax}h`:''}</div>`;
      card.appendChild(head);
      const days = document.createElement('div'); days.className = 'grid grid-cols-5 gap-1 text-xs text-gray-600';
      for(let d=0; d<5; d++){
        const val = dayTotalHours(p.id,d);
        const dViol = (val < (p.dailyMin||0)) || (!!p.dailyMax && val > p.dailyMax);
        const dv = document.createElement('div'); dv.className = 'px-2 py-1 rounded-lg border text-center ' + (dViol? 'border-red-400 text-red-700 bg-red-50':'bg-gray-50');
        dv.textContent = `${DAYS[d]} ${val.toFixed(2)}h`;
        days.appendChild(dv);
      }
      card.appendChild(days); summary.appendChild(card);
      validateDayAndWeek(p.id);
    }
  }

  function validateDayAndWeek(pid){
    const p = state.people.find(x=>x.id===pid); if(!p) return;
    const totalWeek = weekTotalHours(pid); const weekViol = (p.weeklyMin && totalWeek < p.weeklyMin) || (p.weeklyMax && totalWeek > p.weeklyMax);
    for(let d=0; d<5; d++){
      const val = dayTotalHours(pid,d); const dayViol = (p.dailyMin && val < p.dailyMin) || (p.dailyMax && val > p.dailyMax);
      const bars = document.querySelectorAll(`.bar[data-pid=\"${pid}\"][data-day=\"${d}\"]`);
      bars.forEach(b => b.classList.toggle('viol', dayViol || weekViol));
    }
  }

  // ------- Persistence -------
  function save(){ localStorage.setItem('familyPlannerV8', JSON.stringify(state)); }
  function load(){ const s = localStorage.getItem('familyPlannerV8'); if(s){ state = JSON.parse(s); renderAll(); } }
  function reset(){ localStorage.removeItem('familyPlannerV8'); location.reload(); }

  // ------- Diagnostics (tests) -------
  function runDiagnostics(){
    let passed = 0, failed = 0; const logs = [];
    const assert = (name, cond) => { (cond ? passed++ : failed++); logs.push((cond? '✔':'✘')+ ' ' + name); };

    try{
      ensureSchedule();
      assert('schedule created for all people', state.people.every(p=>state.schedule[p.id]));
      assert('5 days present for each person', state.people.every(p=>[0,1,2,3,4].every(d=>Array.isArray(state.schedule[p.id][d]))));

      const pid = state.people[0].id;
      const before = weekTotalHours(pid);
      addInterval(pid, 0, timeToMin(state.startHour), timeToMin(state.startHour)+state.snapMin*2);
      const afterAdd = weekTotalHours(pid);
      assert('adding interval increases week hours', afterAdd > before);
      // remove the last interval we added
      const last = state.schedule[pid][0].slice(-1)[0];
      removeInterval(pid, 0, last.id);
      const afterRemove = weekTotalHours(pid);
      assert('removing interval decreases week hours', afterRemove < afterAdd);

      // Move updates
      const it = state.schedule[pid][1][0];
      const startOld = it.startMin, endOld = it.endMin;
      applyTransformToTimesFromPixels( minToPx( (startOld - timeToMin(state.startHour)) + 30 ), minToPx( (endOld-startOld) ), pid, 1, it);
      assert('move updates start time (snapped)', it.startMin !== startOld);

      // Clamp within day & min duration
      const fake = { id: uid(), startMin: timeToMin(state.startHour)-120, endMin: timeToMin(state.endHour)+120 };
      applyTransformToTimesFromPixels( minToPx(-180), minToPx( (state.endHour-state.startHour)*60 + 600 ), pid, 2, fake);
      const withinBounds = fake.startMin >= timeToMin(state.startHour) && fake.endMin <= timeToMin(state.endHour) && (fake.endMin - fake.startMin) >= state.snapMin;
      assert('clamp within day window & respect min duration', withinBounds);

      // Right-edge resize increases duration and updates caption
      const it2 = state.schedule[pid][2][0];
      const durOld = it2.endMin - it2.startMin;
      const dayStartMin = timeToMin(state.startHour);
      const xPx = minToPx(it2.startMin - dayStartMin);
      const wPx = minToPx((it2.endMin - it2.startMin) + 60); // +1h
      applyTransformToTimesFromPixels(xPx, wPx, pid, 2, it2);
      assert('right resize increases duration', (it2.endMin - it2.startMin) > durOld);
      const barEl = document.querySelector(`.bar[data-iid="${it2.id}"] [data-duration]`);
      const expected = `${fmtHM(it2.startMin)}–${fmtHM(it2.endMin)} (${minsToH(it2.endMin-it2.startMin)}h)`;
      assert('caption updates after resize', barEl && barEl.textContent === expected);
      const capStyle = barEl && getComputedStyle(barEl);
      assert('caption is non-interactive', capStyle && capStyle.pointerEvents === 'none');

      // NEW: small-width bar shows flycap and remains draggable
      const addStart = timeToMin(state.startHour) + 15; // 15 min in
      addInterval(pid, 3, addStart, addStart + 30); // 30 min -> width < 64px at default hour width
      const newest = state.schedule[pid][3].slice(-1)[0];
      const el = document.querySelector(`.bar[data-iid="${newest.id}"]`);
      assert('small bar element exists', !!el);
      assert('small bar has class small', el && el.classList.contains('small'));
      syncFlycapForBar(el);
      assert('flycap is shown for small bar', document.getElementById('flycap').classList.contains('show'));

      console.log('Diagnostics results:\n' + logs.join('\n'));
      toast(`Diagnostics: ${passed} passed, ${failed} failed`);
    } catch(e){
      console.error('Diagnostics error', e);
      toast('Diagnostics error: ' + (e.message||e));
    }
  }

  // ------- Wiring -------
  function renderAll(){ renderPeopleTable(); renderGrid(); }

  document.getElementById('saveBtn').onclick = ()=>{ save(); toast('Saved.'); };
  document.getElementById('loadBtn').onclick = ()=>{ load(); toast('Loaded.'); };
  document.getElementById('resetBtn').onclick = ()=>{ if(confirm('Reset to defaults?')) reset(); };
  document.getElementById('diagBtn').onclick = runDiagnostics;

  document.getElementById('startHour').oninput = e=>{ state.startHour = +e.target.value; renderGrid(); };
  document.getElementById('endHour').oninput = e=>{ state.endHour = +e.target.value; renderGrid(); };
  document.getElementById('snapMin').oninput = e=>{ state.snapMin = +e.target.value; renderGrid(); };
  document.getElementById('hourWidth').oninput = e=>{ state.hourWidth = +e.target.value; renderGrid(); };

  function toast(msg){
    const t = document.createElement('div');
    t.textContent = msg; t.className = 'fixed bottom-4 right-4 bg-black text-white text-sm px-3 py-2 rounded-xl opacity-90 z-50';
    document.body.appendChild(t); setTimeout(()=>t.remove(), 1500);
  }

  // init
  ensureSchedule();
  renderAll();
  </script>
</body>
</html>
